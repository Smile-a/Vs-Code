import atomac
import datetime as dt

from atomac.AXKeyCodeConstants import *
from selenium import webdriver
from time import sleep,time


#企业微信
bundle_id = 'com.tencent.WeWorkMac'

#获取登陆验证码
def getYzmCode():
    #启动应用
    atomac.launchAppByBundleId(bundle_id)
    #获取应用信息
    ato = atomac.getAppRefByBundleId(bundle_id)
    #获取当前应用windows
    cur_win = ato.windows()[0]
    #窗口标题
    #print(cur_win.AXTitle)
    #分离组
    flz = cur_win.findFirstR(AXRole='AXSplitGroup')
    #滚动区
    gdq = flz.findFirstR(AXRole='AXScrollArea')
    #表格
    table = gdq.findFirstR(AXRole='AXTable')
    #表格里所有行；0就是那个状态，我的是疯狂打码中那个,因为我把消息提醒置顶了所以是第一个,后面迭代好点
    rowsAll = table.findAllR(AXRole='AXCell')
    #消息通知的row，预设一下，后面循环匹配，不然emmm如果没有把消息通知设置为置顶，[1]不就找不到了吗
    rows=[]
    #每一个单元格,迭代匹配
    for row in rowsAll:
        #获取每一个单元格里面的，就是聊天联系人左边的
        textArr = row.findFirstR(AXRole='AXStaticText')
        #具体的标题value值，比如'消息通知'栏目,'企业微信团队'之类
        textArrValue = textArr.AXValue
        #因为我们只需要消息通知就判断一下
        if textArrValue == '消息通知':
            #把消息通知栏对象传出去
            rows = row
            break
    #这个单元格下面所有文本框--消息通知里面有3个
    allTexts = rows.findAllR(AXRole='AXStaticText')
    #堡垒机帐号验证码--这里是左边的栏目，然后模拟按钮单击，在右边聊天框里面取验证码，左边栏目里面是没有值的
    xxtzlm = allTexts[1]
    #消息通知栏目的坐标
    xy = xxtzlm.AXPosition
    print('消息通知栏目的坐标:',xy)
    #模拟鼠标单击-消息通知栏
    xxtzlm.clickMouseButtonLeft(xy)
    #等一秒
    sleep(1)
    #不出意外右边的聊天框就是验证码具体信息了，想办法拿到;;从分离区里面拿
    area = flz.findAllR(AXRole='AXScrollArea')[1] #0就是左边的联系人列表，1是右边的聊天框的聊天记录表格
    #右边表格里面的第一个table，就是聊天框，里面都是单元格
    ltb = area.findFirstR(AXRole='AXTable')
    #获取每一个单元格，没个单元格里面都是四个文本框基本上
    lycellArr = ltb.findAllR(AXRole='AXCell')
    #找到最后的一个单元格，就是最新的验证码
    lycell = lycellArr[-1]
    #这个单元格里面所有的文本
    #lttxtDate = lycell.findFirstR(AXRole='AXStaticText') #这是消息标题日期，第一个
    lycelltext = lycell.findFirstR(AXRole='AXTextArea') #这个是堡垒机认证账号那个，是个文本框
    #一整句消息
    vlaue = lycelltext.AXValue
    print(vlaue)
    #截取只要验证码
    yzmCode = vlaue[29:35]
    print(yzmCode)
    #有效期
    yxqDatestr = vlaue[-16:] + ":00"
    print(type(yxqDatestr),yxqDatestr)
    #转成日期对象
    yxqDate = dt.datetime.strptime(yxqDatestr, '%Y-%m-%d %H:%M:%S')
    print(type(yxqDate),yxqDate)
    #比较验证码是否有效，对比时间即可
    now_time = dt.datetime.now()
    print(now_time)
    #判断有效期是否大于当前时间
    isEff = yxqDate > now_time
    print(isEff)
    if isEff:
        print("验证码有效!")
    else:
        print("验证码过期了!")
    #后期再加上是否有效的逻辑，目前先都放行
    #用在浏览器页面的登陆验证码
    dxyzm = ''
    dxyzm = yzmCode
    print(dxyzm)
    #关闭企业微信的窗口
    closeBtn = cur_win.AXCloseButton
    closeBtn.Press()
    return dxyzm

#谷歌浏览器驱动配置
options = webdriver.ChromeOptions()
#selenium默认是会执行完关闭浏览器的，这样设置一下先不关闭，最后执行手动quit即可。
options.add_experimental_option('detach', True)
#加载谷歌浏览器驱动
chrome = webdriver.Chrome(options=options)
#设置浏览器窗口最大化
chrome.maximize_window()
#登陆
chrome.get("http://www.baidu.com")
#codeing...
yzm = getYzmCode()
print('获得企微验证码:',yzm)
print("执行操作，完成后关闭浏览器")
#刷新浏览器
#chrome.refresh()
#关闭浏览器
chrome.quit()