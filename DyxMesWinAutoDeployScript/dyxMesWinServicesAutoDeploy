import os
import sys
import ddddocr
import pyautogui
import pytesseract
import datetime as dt
import pyperclip
import tkinter as tk
import requests
import dyxServerConfig

from tkinter import messagebox
from selenium import webdriver
from selenium.webdriver.common.by import By
from time import sleep,time
from pywinauto.application import Application
from pywinauto import mouse
from pyautogui import scroll
from PIL import Image


#要登陆堡垒机的账号和密码
qwAccount='anwei'
qwPassword='An123456'
#企业微信地址
wxWorkPath = 'C:\Program Files (x86)\WXWork\WXWork.exe'
title = '企业微信'
# 设置自动化操作时间间隔
pyautogui.PAUSE = 0.5

#获取企业微信消息通知里面的最新的登录验证码
def getYzmCode():
    #打开企业微信应用
    app = Application(backend='uia').start(wxWorkPath)
    sleep(2)
    #链接到企业微信
    app = Application(backend='uia').connect(title=title)
    #选中企业微信窗口
    wind_calc = app[title]
    #获取当前窗口显示的坐标
    coordinate = wind_calc.rectangle()
    print(coordinate)

    # 程序左边缘距离显示器左边缘的像素
    l_coordinate = coordinate.left
    # 程序右边缘距离显示器左边缘的像素
    r_coordinate = coordinate.right
    # 程序上边缘距离显示器上边缘的像素
    t_coordinate = coordinate.top
    # 程序下边缘距离显示器上边缘的像素
    b_coordinate = coordinate.bottom

    #选中消息
    mouse.click(coords=(l_coordinate + 25, b_coordinate - 550))
    #打开通讯录
    #mouse.click(coords=(l_coordinate + 25, b_coordinate - 220))
    #打开文档
    #mouse.click(coords=(l_coordinate + 25, b_coordinate - 440))
    
    #当前鼠标在消息图标上，挪动到消息通知上面，暂时简单做法就是制定消息通知，让鼠标点过去，高级点就先点搜索框就有点麻烦了
    x,y = pyautogui.position()
    mouse.double_click(coords=(x + 73, y + 28))
    print("鼠标当前位置:",pyautogui.position())
    #滚轮上滑
    scroll(20)
    #选中企业微信窗口
    wind_msg = app['消息通知']
    #获取当前窗口显示的坐标
    print('消息通知窗口位置:',wind_msg.rectangle())
    wind_msg_left = wind_msg.rectangle().left
    wind_msg_top = wind_msg.rectangle().top
    wind_msg_right = wind_msg.rectangle().right
    wind_msg_bottom = wind_msg.rectangle().bottom
    #获取消息通知的结构
    #print(wind_msg.print_control_identifiers())
    # 本来准备获取窗体内容的 也确实这么做了，奈何太菜了 只能换个路子了,截图或者定位  以后再看看能不能获取窗体在试试
    # 直接截图 这时候是双击的消息通知窗口直接通过消息通知定位
     # 屏幕的宽度和高度
    width, height = pyautogui.size()
    print("当前屏幕尺寸:",width, height)
    #pyautogui.alert(text='寻找定位中...', title='提示', button='OK')
    # 不这样傻傻移动可以用截图匹配 也可以
    # 移动鼠标到窗口聊天框中心 然后下滑动不滑也不是不行
    mouse.double_click(coords=(wind_msg_left + 500, wind_msg_top + 100))
    scroll(-10)
    #截图 太妙了 他的聊天记录log刚好对应验证码!!
    qwGpslogo = pyautogui.locateOnScreen('qwGpslogo.png')
    print('聊天记录log位置:',qwGpslogo)
    qwGpslogoX = qwGpslogo.left + 10
    qwGpslogoY = qwGpslogo.top - 50
    #移动鼠标到聊天框那--定位的是图片log左上角，往上走双击直接获取验证码
    #pyautogui.moveTo(qwGpslogoX,qwGpslogoY)
    mouse.double_click(coords=(qwGpslogoX, qwGpslogoY))
    #到这，就获取到了企业微信聊天框里面验证码了
    pyautogui.hotkey('ctrl', 'c')
    #然后关闭这个窗口，不然下次打开找不到会出问题，其实可以在上面获取消息通知的时候做判断，如果已经打开了就直接找过去辅助就行，但是先这样吧
    print('聊天记录log关闭按钮位置:',wind_msg_right,wind_msg_top)
    qwGpslogoCloseX = wind_msg_right - 10
    qwGpslogoCloseY = wind_msg_top + 10
    #单击关闭按钮
    mouse.click(coords=(qwGpslogoCloseX, qwGpslogoCloseY))
    #最小化企业微信的窗口
    wind_calc.minimize()
    yzm = pyperclip.paste()
    return yzm

def customer():
    # 输入提示框， 显示带有文本输入以及确定和取消按钮的消息框
    customer_name = pyautogui.prompt(text='', title='搜索', default='搜索')
    return customer_name

#持续获取当前鼠标坐标
def getPoint():
    for i in range(20):
        print("鼠标当前位置:",pyautogui.position())
        sleep(0.5)

#用tk做一个弹窗提示 自动关闭
def alterAuto(s):
    root = tk.Tk()  # 搞个tk
    root.withdraw() # 隐藏tk窗口 
    root.after(s, root.destroy) # 设置过时时间，单位为毫秒，超过s毫秒后运行root.destroy方法
    ss = int(s / 1000)
    messagebox.showinfo("提示", "该提示框在"+ str(ss) +"s后自动关闭,因为考虑到网络因素稍等一下~")
    #root.mainloop() # 加入主循环   如果注释掉这一行，程序将在创建窗口后立即结束,我做提示框要的就是这个

#获取登陆页面的验证码,可以单击更换
def getVcodeImg(vcodeImg):
    print('img:',vcodeImg)
    vcodeImg.screenshot("code.png")  # 下载图片
    sleep(2)
    with open("code.png", "rb") as fp:
        img = fp.read()
    #识别图片验证码
    ocr = ddddocr.DdddOcr()
    imgYzm = ocr.classification(img)
    print('识别图片验证码:',imgYzm)
    return imgYzm



# 先把路径切进来
print("我要开始自动化了~")
print("当前路径",os.getcwd())
os.chdir("C:\MyProject\Vs-Code\DyxMesWinAutoDeployScript")
print("切换路径，当前路径",os.getcwd())
print("鼠标当前位置:",pyautogui.position())

#谷歌浏览器驱动配置
print("开始操作浏览器~")
options = webdriver.ChromeOptions()
#selenium默认是会执行完关闭浏览器的，这样设置一下先不关闭，最后执行手动quit即可。
options.add_experimental_option('detach', True)
#加载谷歌浏览器驱动
chrome = webdriver.Chrome(options=options)
#设置浏览器窗口最大化
chrome.maximize_window()
#登陆dyx
chrome.get("https://10.157.234.151/index.php/Public/index/stra_name/sms_local")
#sleep(3)
alterAuto(3000)
#这个地址一打开就说不安全，点击高级按钮然后访问真实地址就可以正常登录了
gaojiButton = chrome.find_element(By.ID,'details-button')
gaojiButton.click()
sleep(1)
#选择继续访问，点击
jixuButton = chrome.find_element(By.ID,'proceed-link')
jixuButton.click()
sleep(1)
#不出意外的话都打开了
#输入账号
account = chrome.find_element(By.NAME,'account')
account.send_keys(qwAccount)
sleep(1)
#本地密码
local = chrome.find_element(By.NAME,'local')
local.send_keys(qwPassword)
sleep(1)
#单击按钮-发送验证码
send_mobile_codeButton = chrome.find_element(By.ID,'send_mobile_code')
send_mobile_codeButton.click()
#这时候会有一个系统弹窗，说发送成功,把它关掉
sleep(1)
chrome.switch_to.alert.accept()
#怕有时候网络不行，所以才等一会
#sleep(5)
alterAuto(5000)
#获取企业微信收到的验证码
yzm = getYzmCode()
print('获得企微验证码:',yzm)
#短信密码填入
sms = chrome.find_element(By.NAME,'sms')
sms.send_keys(yzm)
#调用图像识别，取到图片验证码
vcodeImg = chrome.find_element(By.ID,'vcode')
imgYzm = getVcodeImg(vcodeImg)
#最多10下吧，就不信10次还有这样的验证码
i = 1
while i <= 10:
    #判断验证码有没有o，O，0 这些，目前这个识别会失败，那就直接换一个新的就好了
    if len(imgYzm) < 4:
        vcodeImg.click()
        imgYzm = getVcodeImg(vcodeImg)
    elif 'o' in imgYzm:
        vcodeImg.click()
        imgYzm = getVcodeImg(vcodeImg)
    elif 'O' in imgYzm:
        vcodeImg.click()
        imgYzm = getVcodeImg(vcodeImg)
    elif '0' in imgYzm :
        vcodeImg.click()
        imgYzm = getVcodeImg(vcodeImg)
    elif '1' in imgYzm :
        vcodeImg.click()
        imgYzm = getVcodeImg(vcodeImg)
    elif '工' in imgYzm :
        vcodeImg.click()
        imgYzm = getVcodeImg(vcodeImg)
    elif '5' in imgYzm :
        vcodeImg.click()
        imgYzm = getVcodeImg(vcodeImg)
    else :
        print(imgYzm)
        break
    i += 1
#验证码输入框
verify = chrome.find_element(By.NAME,'verify')
verify.send_keys(imgYzm)
sleep(1)
#登陆按钮触发
submit = chrome.find_element(By.ID,'submit')
submit.click()
print("执行操作,不出意外登陆成功!")
#是否登陆成功
errBox = chrome.find_element(By.ID,'errBox')
errBoxSpan = errBox.get_attribute('innerHTML')
print(errBoxSpan)
#一般登陆成功就啥也没有，如果登陆失败才会有字，而且账号密码验证码基本都不会有问题，只有可能是验证码也就是"*验证码不正确！"
if errBoxSpan != '':
    #以后可以改成重新来一遍登陆流程，现在就先结束
    #关闭浏览器
    chrome.quit()
    #搞个提示框告诉一下失败了
    closeTk = tk.Tk()  # 搞个tk
    closeTk.withdraw() # 隐藏tk窗口 
    closeTk.after(3000, closeTk.destroy) # 设置过时时间，单位为毫秒，超过s毫秒后运行root.destroy方法
    messagebox.showerror("错误", "本次登录遇到了一点点问题，请重新启动试试~~")
    #程序结束
    sys.exit()
#等一下加载
sleep(5)
#刷新浏览器
chrome.refresh()
#全局搜索页面
allList = 'https://10.157.234.151/index.php/UserWork/index/type/all/cpu/64'
chrome.get(allList)
#emmmmm
sleep(2)
devIdUrl = 'https://10.157.234.151/index.php/UserWork/operation/dgrp_id/0/dev_id/' + '763'
chrome.get(devIdUrl)
#然后点击页面的那个按钮？打开
sleep(1)
#requests.post('http://127.0.0.1:8888/RunTerm',{'data':''+dyxServerConfig.test_10_156_53_58['Xshell']+''})
sleep(1)
requests.post('http://127.0.0.1:8888/RunWinScp',{'data':''+dyxServerConfig.test_10_156_53_58['winscp']+''})
#关闭浏览器
#chrome.quit()
print("自动化结束了~")